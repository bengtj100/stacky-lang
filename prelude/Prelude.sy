# Stacky Prelude

## *Copyright (c) 2024 Bengt Johansson <bengtj100 at gmail dot com> - All rights reserved.*

This software is part of the stacky project and its use is
regulated by the conditions stipulated in the file named 'LICENCE',
located in the top directory of said project.

## Prelude book-keeping operations
```
[ [isInteractive] [@] [drop] ? ] 'ifInteractive;

[ "\nLoading the Prelude ... " put] ifInteractive

```

## List operations

### `nil` - The empty list

```
[ [] ] 'nil;
```

### `fromSeq` - Break a sequence (string or list) and place it on the stack

```
[
    [dup typeOf "list" =] [fromList "list"] [fromString "string"] ?
] 'fromSeq;
```

### `toSeq` - Make a specified sequence (string or list) from values on the stack

```
[
   ["list" =] [toList] [toString] ?
] 'toSeq;
```

### `cons` - Add an element to the beginning of a sequence (string or list)

This operation takes an element and a list and prepends the element to the beginning of the list.

~~~
       [x_0 [x_1 ... x_n] <] ---> [ [x_0 x_1 ... x_n] <]
cons : or
       [c_0 "c_1 ... c_n" <] ---> [ "c_0 c_1 ... c_n" <]
~~~

Examples:

~~~
> 999 [100 200 300] cons
[ [999 100 200 300] <]

> "H" "ELLO" cons
[ "HELLO" <]
~~~

```
[
    [ 2 "cons"] expectDepth
    [ "sequence" 0 -1 "cons" ] expectType
    
    fromSeq swap 1 + swap toSeq

] 'cons;
```

### `head` - Get the first element of a sequence (string or list)

This operation takes a non-empty sequence and returns the first element.

~~~
head : [ [x_1 x_2 ... x_n] <] ---> [ x_1 <]
~~~

Examples:

~~~
> [1 2 3 4] head
[ 1 <]

> "FOO" head
[ "F" <]

> [] head
./prelude/Prelude.sy:60:19: ERROR: Operation 'expectType' expects a value of type 'sequence(1,-1)', got '[] : list(0)'
~~~

```
[
    [ 1 "head"] expectDepth
    [ "sequence" 1 -1 "head" ] expectType
    
    0 1 slice fromSeq 2 ndrop

] 'head;
```

### `tail` - Remove the first element from a non-empty list.

This operation removes the first element from a non-empty list.

~~~
tail : [ [x_1 x_2 ... x_n] <] ---> [ [x_2 ... x_n] <]
~~~

Examples:

~~~
> [1 2 3 4] tail
[ [2 3 4] <]
> [] tail
./prelude/Prelude.sy:91:25: ERROR: Operation 'tail' expects a value of type 'sequence(1,-1)', got '[] : list(0)'
~~~

```
[
    [ 1 "tail"] expectDepth
    [ "sequence" 1 -1 "tail" ] expectType

    1 over length slice
    
] 'tail;
        
```

### `init` - Remove the last element of a non-empty list

~~~
init : [ [x_1 ... x_(n-1) x_n] <] ---> [ [x_1 ... x_(n-1)] <]
~~~

Examples:

~~~
> [1 2 3 4] init
[ [1 2 3] <]

> [1] init
[ [] <]

> [] init
./prelude/Prelude.sy:110:25: ERROR: Operation 'init' expects a value of type 'sequence(1,-1)', got '[] : list(0)'
~~~

```
[
    [ 1 "init"] expectDepth
    [ "sequence" 1 -1 "init" ] expectType

    0 over length 1 - slice

] 'init;

```

### `last` - Return the last element of e non-empty list

~~~
last : [ [x_1 ... x_n] <] ---> [ x_n <]
~~~

Examples:

~~~
> [1 2 3 4] last
[ 4 <]
~~~

```
[
    [ 1 "last"] expectDepth
    [ "sequence" 1 -1 "last" ] expectType

    dup length dup 1 - swap slice

] 'last;
```

## String operations

### The `explode` and `implode` operations

The `explode` operation converts strings into lists of one-character strings for easy processing by list operations.

The `implode` operation is the inverse of `explode`, it takes a list of strings and concatenates it to a string again.

~~~
explode : [ s:string(n) <] ---> [ cs:list(n,string(1)) <]

implode : [ cs::list(n,string(1)) <] ---> [ s:string(n) <]
~~~

Examples:

~~~
> "HELLORLD"
[ "HELLORLD" <]
> explode
[ ["H" "E" "L" "L" "O" "R" "L" "D"] <]
> reverse
[ ["D" "L" "R" "O" "L" "L" "E" "H"] <]
> implode
[ "DLROLLEH" <]
~~~

```
[
    [ 1 "explode"] expectDepth
    [ "string" 0 -1 "explode" ] expectType
        
    fromString toList

] 'explode;

[
    [ 1 "implode"] expectDepth
    [ "list" 0 -1 "implode" ] expectType
        
    fromList toString

] 'implode;
```
# THAT'S ALL FOLKS!!

```
[ "DONE\n\n" put] ifInteractive
```
