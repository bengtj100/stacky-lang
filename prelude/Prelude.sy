
[comment]: # (-*-Markdown-*-  First line intentionally left blank!)


# Stacky Prelude

## *Copyright (c) 2024 Bengt Johansson <bengtj100 at gmail dot com> - All rights reserved.*

This software is part of the stacky project and its use is
regulated by the conditions stipulated in the file named 'LICENCE',
located in the top directory of said project.

## Prelude book-keeping operations

```
[ [isInteractive] [@] [drop] ? ] 'ifInteractive;

[ "\nLoading the Prelude ... " put] ifInteractive

```

## Logical and boolean operations

```
0 'false;
1 'true;
```

## Mathematical operations

```
[ 1.0 + floor ] 'ceil;

[ 0.5 + floor ] 'round;

1.0 asin 2.0 * 'pi;

1.0 exp 'euler;


1.0  0.0 / 'PosInf;
-1.0 0.0 / 'NegInf;

PosInf 'Infinity;
```

## List operations

### `nil` - The empty list

Implementation:

```
[ [] ] 'nil;
```

### `index` - Get the n:th element of a sequence

Implementation:

```
[ dup 1 + slice head ] 'index;
```

### `fromSeq` - Break a sequence (string or list) and place it on the stack

Implementation:

```
[
    [dup typeOf "list" =] [fromList "list"] [fromString "string"] ?
] 'fromSeq;
```

### `toSeq` - Make a specified sequence (string or list) from values on the stack

Implementation:

```
[
   ["list" =] [toList] [toString] ?
] 'toSeq;
```

### `cons` - Add an element to the beginning of a sequence (string or list)

This operation takes an element and a list and prepends the element to the beginning of the list.

~~~
       [x_0 [x_1 ... x_n] <] ---> [ [x_0 x_1 ... x_n] <]
cons : or
       [c_0 "c_1 ... c_n" <] ---> [ "c_0 c_1 ... c_n" <]
~~~

Examples:

~~~
> 999 [100 200 300] cons
[ [999 100 200 300] <]

> "H" "ELLO" cons
[ "HELLO" <]
~~~

Implementation:

```
[
    [ 2 "cons"] expectDepth
    [ "sequence" 0 -1 "cons" ] expectType
    
    fromSeq swap 1 + swap toSeq

] 'cons;
```

### `head` - Get the first element of a sequence (string or list)

This operation takes a non-empty sequence and returns the first element.

~~~
head : [ [x_1 x_2 ... x_n] <] ---> [ x_1 <]
~~~

Examples:

~~~
> [1 2 3 4] head
[ 1 <]

> "FOO" head
[ "F" <]

> [] head
./prelude/Prelude.sy:60:19: ERROR: Operation 'expectType' expects a value of type 'sequence(1,-1)', got '[] : list(0)'
~~~

Implementation:

```
[
    [ 1 "head"] expectDepth
    [ "sequence" 1 -1 "head" ] expectType
    
    0 1 slice fromSeq 2 ndrop

] 'head;
```

### `tail` - Remove the first element from a non-empty list.

This operation removes the first element from a non-empty list.

~~~
tail : [ [x_1 x_2 ... x_n] <] ---> [ [x_2 ... x_n] <]
~~~

Examples:

~~~
> [1 2 3 4] tail
[ [2 3 4] <]
> [] tail
./prelude/Prelude.sy:91:25: ERROR: Operation 'tail' expects a value of type 'sequence(1,-1)', got '[] : list(0)'
~~~

Implementation:

```
[
    [ 1 "tail"] expectDepth
    [ "sequence" 1 -1 "tail" ] expectType

    1 over length slice
    
] 'tail;
        
```

### `init` - Remove the last element of a non-empty list

~~~
init : [ [x_1 ... x_(n-1) x_n] <] ---> [ [x_1 ... x_(n-1)] <]
~~~

Examples:

~~~
> [1 2 3 4] init
[ [1 2 3] <]

> [1] init
[ [] <]

> [] init
./prelude/Prelude.sy:110:25: ERROR: Operation 'init' expects a value of type 'sequence(1,-1)', got '[] : list(0)'
~~~

Implementation:

```
[
    [ 1 "init"] expectDepth
    [ "sequence" 1 -1 "init" ] expectType

    0 over length 1 - slice

] 'init;

```

### `last` - Return the last element of e non-empty list

~~~
last : [ [x_1 ... x_n] <] ---> [ x_n <]
~~~

Examples:

~~~
> [1 2 3 4] last
[ 4 <]
~~~

Implementation:

```
[
    [ 1 "last"] expectDepth
    [ "sequence" 1 -1 "last" ] expectType

    dup length dup 1 - swap slice head

] 'last;
```

### The `left`, `mid`, and `right` operations

These operations mimic the well known BASIC string functions `LEFT$`, `MID$`, and `RIGHT$`.

* `left` takes a sequence and returns the *n* first elements of the sequence.
* `mid` takes a sequence and returns the *n* first elements starting at element *m*.
* `right` takes a sequence and returns the *n* last elements of the sequence.

~~~
left  : [ s:sequence(l) n:integer[n<=l] <]               ---> [ s':sequence(n) <]
right : [ s:sequence(l) n:integer[n<=l] <]               ---> [ s':sequence(n) <]
mid   : [ s:sequence(l) m:integer[n<=l] n:integer[m+n<l] ---> [ s':sequence(n) <]
~~~

Examples:

~~~
> "HELLORLD" 5 left
[ "HELLO" <]

> "HELLORLD" 3 right
[ "RLD" <]

> "HELLORLD"
[ "HELLORLD" <]
> dup 5 left
[ "HELLORLD" "HELLO" <]
> " W" 
[ "HELLORLD" "HELLO" " W" <]
> 3 nover 4 right
[ "HELLORLD" "HELLO" " W" "ORLD" <]
> 3 toString
[ "HELLORLD" "HELLO WORLD" <]
~~~

Implementation:

```
[
    [ 2 "left"] expectDepth
    over [ "sequence" 1 -1 "left" ] expectType drop
    [ "integer" 1 2 "left" ] expectType

    0 swap slice
] 'left;

[
    [ 2 "right"] expectDepth
    over [ "sequence" 1 -1 "right" ] expectType drop
    [ "integer" 1 2 "right" ] expectType

    over length
    dup rot -
    swap slice
] 'right;

[
    [ 3 "mid"] expectDepth
    3 nover [ "sequence" 1 -1 "mid" ] expectType drop
    over [ "integer" 1 2 "mid" ] expectType drop
    [ "integer" 1 2 "mid" ] expectType

    over + slice
] 'mid;
```

### The `map`, `filter`, and `fold` operations

These operations implement the common list combinators `map`, `filter`, and `fold` which are well-known in functional programming.

The `map` operation takes a list (or string) and applies a function to each of the elements of that list.

~~~
map    : [ [x_1 ... x_n] f <] ---> [ [f(x_1) ... f(x_n) ] <]
~~~

Example. Take the square of all elements:

~~~
> [1 2 3 4 5] [dup *] map
[ [1 4 9 16 25] <]
~~~

The `filter` operation applies a predicate to each of the elements in a sequence (string or list) and keeps only those that satisfies the predicate.

~~~
filter : [ [x_1 ... x_n] pred <] ---> [ x_k_1 ... x_k_m ] <]
         where x_k_1 ... x_k_m are all elements that satisfies the predicate
~~~

Example. Keep the even numbers in the list:

~~~
> [1 2 3 4 5 6 7 8 9 10] [2 % 0 =] filter
[ [2 4 6 8 10] <]
~~~

The `fold` operation takes a list, an operation and its zero element and applies the operation on all elements, effectively *folding* the list to a single value.

~~~
fold   : [ [x_1 ... x_n] zero op <] ---> [ (zero op (x_1 op (x_2 op (... op x_n)...) <]
~~~

Example. Sum all elements in a list.

~~~
> [1 2 3 4 5 6 7 8 9 10] 0 '+ fold
[ 55 <]
~~~

Implementation:

```
[
    'f; 'xs;
    [^xs]
        [
            ^xs head f
            ^xs tail ^f map
            cons
        ]
        [
            []
        ] ?
] 'map;

[
    'pred; 'xs;
    [^xs]
        [
            ^xs head              'hd;
            ^xs tail ^pred filter 'tl;
            [^hd pred] [^hd ^tl cons] [^tl] ?
        ]
        [
            []
        ] ?
]'filter;

[
    'op; 'acc; 'xs;
    [^xs]
        [
            ^xs tail
            ^acc ^xs head op
            ^op
            fold
        ]
        [
            ^acc
        ] ?
] 'fold;
```

## String operations

### The `explode` and `implode` operations

The `explode` operation converts strings into lists of one-character strings for easy processing by list operations.

The `implode` operation is the inverse of `explode`, it takes a list of strings and concatenates it to a string again.

~~~
explode : [ s:string(n) <] ---> [ cs:list(n,string(1)) <]

implode : [ cs::list(n,string(1)) <] ---> [ s:string(n) <]
~~~

Examples:

~~~
> "HELLORLD"
[ "HELLORLD" <]
> explode
[ ["H" "E" "L" "L" "O" "R" "L" "D"] <]
> reverse
[ ["D" "L" "R" "O" "L" "L" "E" "H"] <]
> implode
[ "DLROLLEH" <]
~~~

Implementation:

```
[
    [ 1 "explode"] expectDepth
    [ "string" 0 -1 "explode" ] expectType
        
    fromString toList

] 'explode;

[
    [ 1 "implode"] expectDepth
    [ "list" 0 -1 "implode" ] expectType
        
    fromList toString

] 'implode;
```

## Input/output operations

### `input`

```
[ "? " prompt ] 'input;
```

# THAT'S ALL FOLKS!!

```
[ "DONE\n\n" put] ifInteractive
```
